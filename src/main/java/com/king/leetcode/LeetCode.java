package com.king.leetcode;

import java.util.*;

/**
 * @author <a href="mailto:jenly1314@gmail.com">Jenly</a>
 */
public class LeetCode {

    /**
     * 1. 两数之和
     * @param nums
     * @param target
     * @return
     */
    public int[] twoSum(int[] nums, int target) {
        int length = nums.length;
        for(int i = 0; i < length; i++){
            for(int j = i + 1; j < length; j++){
                if(nums[i] + nums[j] == target){
                    return new int[]{i,j};
                }
            }
        }
        return null;
    }

    /**
     * 2. 两数相加
     * @param l1
     * @param l2
     * @return
     */
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {

        ListNode listNode = new ListNode(0);
        addTwoNumbers(listNode,l1,l2,0);
        return listNode;
    }

    private void addTwoNumbers(ListNode listNode,ListNode l1, ListNode l2,int val) {

        if(l1 != null){
            val += l1.val;
        }
        if(l2 != null){
            val += l2.val;
        }

        listNode.val = val % 10;

        val /= 10;

        ListNode next1 = null;
        if (l1 != null) {
            next1 = l1.next;
        }

        ListNode next2 = null;
        if (l2 != null) {
            next2 = l2.next;
        }

        if (next1 != null || next2 != null) {
            listNode.next = new ListNode(val);
            addTwoNumbers(listNode.next, next1, next2, val);
        } else if (val > 0) {
            listNode.next = new ListNode(val);
        }

    }

    /**
     * 3. 无重复字符的最长子串
     * @param s
     * @return
     */
    public int lengthOfLongestSubstring(String s) {
        int length = s.length();

        Map<Character,Integer> map = new HashMap<>();
        int max = 0;
        int j = 0;
        for(int i = 0; i < length; i++){
            char ch = s.charAt(i);
            if(map.containsKey(ch)){
                j = Math.max(j,map.get(ch));
            }
            max = Math.max(max, i - j + 1);
            map.put(ch,i + 1);
        }

        return max;
    }

    /**
     * 4. 寻找两个有序数组的中位数
     * @param nums1
     * @param nums2
     * @return
     */
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        if(nums1 == null || nums1.length == 0){
            return findMedianSortedArrays(nums2);
        }

        if(nums2 == null || nums2.length == 0){
            return findMedianSortedArrays(nums1);
        }

        int length1 = nums1.length;
        int length2 = nums2.length;
        int length = length1 + length2;
        int [] nums = new int[length];
        boolean bool = false;
        for(int i = 0, j = 0, k = 0; i < length; i++){
            if(bool){
                nums[i] = nums1[j];
                j++;
            }else{
                if(j < length1 && nums1[j] < nums2[k]){
                    nums[i] = nums1[j];
                    j++;
                }else{
                    nums[i] = nums2[k];
                    if(k >= length2 - 1){
                        bool = true;
                    }else{
                        k++;
                    }
                }
            }
        }

        return findMedianSortedArrays(nums);

    }

    private double findMedianSortedArrays(int[] nums){
        int length = nums.length;
        if(length == 1){
            return nums[0];
        }

        if(length % 2 == 0){
            int i = length / 2;
            return (nums[i] + nums[i - 1]) / 2.0f;
        }
        return nums[length / 2];
    }

    /**
     * 5. 最长回文子串
     * @param s
     * @return
     */
    public String longestPalindrome(String s) {
        int length = s.length();
        if(length <= 1){
            return s;
        }

        String str = "";
        for(int i = 0; i < length; i++){
            char chl = s.charAt(i);
            String sl = longestPalindrome(chl,s.substring(i));

            if(sl.length() > str.length()){
                str = sl;
            }
        }

        return str;
    }

    private String longestPalindrome(char ch, String s){

        int length = s.length();
        if(length <= 1){
            return s;
        }

        if(isPalindrome(s)){
            return s;
        }

        int index = s.lastIndexOf(ch);
        if(index == length - 1){
            s = s.substring(0,index);
        }else{
            s = s.substring(0,index + 1);
        }
        if(index > 0){
            return longestPalindrome(ch,s);
        }

        return String.valueOf(ch);
    }

    private boolean isPalindrome(String s){
        int length = s.length();
        if(length <= 1){
            return true;
        }
        int size = length / 2;
        for(int i = 0; i < size; i++){
            if(s.charAt(i) != s.charAt(length - i - 1)){
                return false;
            }
        }
        return true;
    }


    /**
     * 6. Z 字形变换
     * @param s
     * @param numRows
     * @return
     */
    public String convert(String s, int numRows) {
        if(numRows < 2){
            return s;
        }
        int length = s.length();
        int cols =  length - (length / numRows) + numRows;
        char[][] ss = new char[cols][numRows];
        boolean isBool = true;
        for(int i = 0, j = 0, k = 0; i < length; i++){
            char c = s.charAt(i);

            if(isBool){
                ss[j][k] = c;
                if(k == numRows - 1){
                    isBool = false;
                }else{
                    k++;
                }
            }else{
                k--;
                j++;
                ss[j][k] = c;
                if(k == 0){
                    isBool = true;
                    k++;
                }
            }

        }

        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < numRows; i++){
            for(int j = 0; j < cols; j++){
                char ch = ss[j][i];
                if(ch != '\u0000'){
                    sb.append(ss[j][i]);
                }
            }
        }

        return sb.toString();
    }

    /**
     * 7. 整数反转
     * @param x
     * @return
     */
    public int reverse(int x) {
        long reverse = 0;
        while(x != 0){
            int temp = x % 10;
            x /= 10;
            reverse  = reverse * 10 + temp;

            if(reverse > Integer.MAX_VALUE || reverse < Integer.MIN_VALUE) {
                return 0;
            }
        }

        return (int)reverse;
    }

    /**
     * 8. 字符串转换整数 (atoi)
     * @param str
     * @return
     */
    public int myAtoi(String str) {
        str = str.trim();
        int length = str.length();

        int n = 0;
        int j = length;
        boolean isMinus = false;
        for(int i = 0; i < length; i++){
            char ch = str.charAt(i);
            if(i == 0){
                if(ch == '0'){
                    n = 1;
                }else if(ch == '+'){
                    n = 1;
                }else if(ch == '-'){
                    n = 1;
                    isMinus = true;
                } else if(ch < 48 || ch > 57){
                    return 0;
                }
            }else if(n == i && ch == '0'){
                n++;
            }else if(ch < 48 || ch > 57){
                j = i;
                break;
            }
        }
        int size = j - n;

        if(size > 0){
            if(size > 10){
                if(isMinus){
                    return Integer.MIN_VALUE;
                }
                return Integer.MAX_VALUE;
            }

            str = str.substring(n, j);
            long l = Long.parseLong(str);

            if(isMinus){
                l = -l;
                if(l < Integer.MIN_VALUE){
                    return Integer.MIN_VALUE;
                }
                return (int)l;
            }

            if(l > Integer.MAX_VALUE){
                return Integer.MAX_VALUE;
            }

            return Integer.parseInt(str);
        }

        return 0;
    }

    /**
     * 9. 回文数
     * @param x
     * @return
     */
    public boolean isPalindrome(int x) {
        if(x < 0) {
            return false;
        }
        int value = x;
        long reverse = 0;
        while( x != 0){
            int temp =  x % 10;
            x /= 10;
            reverse = reverse * 10 + temp;
        }

        return value == reverse;
    }

    /**
     * 10. 正则表达式匹配
     * @param s
     * @param p
     * @return
     */
    public boolean isMatch(String s, String p) {
        return false;
    }


    /**
     * 11. 盛最多水的容器
     * @param height
     * @return
     */
    public int maxArea(int[] height) {
        int n = height.length;
        int ans = 0;
        for(int i = 0; i < n - 1; i++){
            for(int j = i + 1; j < n; j++){
                int max = (j - i) * Math.min(height[i],height[j]);
                if(max > ans){
                    ans = max;
                }
            }
        }

        return ans;
    }

    /**
     * 12. 整数转罗马数字
     * @param num
     * @return
     */
    public String intToRoman(int num) {

        StringBuilder sb = new StringBuilder();
        while (num > 0){
            if(num >= 1000){
                num -= 1000;
                sb.append('M');
            }else if(num >= 900){
                num -= 900;
                sb.append("CM");
            }else if(num >= 500){
                num -= 500;
                sb.append('D');
            }else if(num >= 400){
                num -= 400;
                sb.append("CD");
            }else if(num >= 100){
                num -= 100;
                sb.append('C');
            }else if(num >= 90){
                num -= 90;
                sb.append("XC");
            }else if(num >= 50){
                num -= 50;
                sb.append('L');
            }else if(num >= 40){
                num -= 40;
                sb.append("XL");
            }else if(num >= 10){
                num -= 10;
                sb.append('X');
            }else if(num >= 9){
                num -= 9;
                sb.append("IX");
            }else if(num >= 5){
                num -= 5;
                sb.append('V');
            }else if(num >= 4){
                num -= 4;
                sb.append("IV");
            }else if(num >= 1){
                num -= 1;
                sb.append('I');
            }
        }

        return sb.toString();
    }

    /**
     * 13. 罗马数字转整数
     * @param s
     * @return
     */
    public int romanToInt(String s) {
        Map<Character,Integer> map = new HashMap<>(7);
        map.put('I',1);
        map.put('V',5);
        map.put('X',10);
        map.put('L',50);
        map.put('C',100);
        map.put('D',500);
        map.put('M',1000);
        int sum = 0;
        int preValue = map.get(s.charAt(0));
        for(int i = 1; i < s.length(); i++){
            int value = map.get(s.charAt(i));
            if(preValue >= value){
                sum += preValue;
            }else{
                sum -= preValue;
            }
            preValue = value;
        }

        sum += preValue;

        return sum;
    }

    /**
     * 14. 最长公前缀
     * @param strs
     * @return
     */
    public String longestCommonPrefix(String[] strs) {
        String prefix = "";
        if(strs != null && strs.length > 0){
            int minLength = strs[0].length();
            int size = strs.length;
            for(int i = 1;i < size; i++){
                int len = strs[i].length();
                if(len < minLength){
                    minLength = len;
                }
            }

            for(int i = 1; i <= minLength; i++){
                String temp = strs[0].substring(0,i);
                for(int j = 1; j < size; j++){
                    if(!strs[j].startsWith(temp)){
                        return prefix;
                    }
                }
                prefix = temp;

            }
        }

        return prefix;
    }


    /**
     * 15. 三数之和
     * @param nums
     * @return
     */
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> list = new ArrayList<>();
        int length = nums.length;
        if(length >= 3){
            Arrays.sort(nums);
            if(nums[length - 1] >= 0){
                int i = 0;
                while (i < length - 2){
                    int n = nums[i];
                    if(n > 0){
                        break;
                    }

                    int left = i + 1;
                    int right = length - 1;
                    while (left < right){
                        if( n > 0 && nums[right] > 0){
                            break;
                        }

                        if(n < 0 && nums[right] < 0){
                            break;
                        }

                        int sum = n + nums[left] + nums[right];
                        if(sum == 0){
                            List<Integer> item = new ArrayList<>();
                            item.add(n);
                            item.add(nums[left]);
                            item.add(nums[right]);
                            list.add(item);
                        }

                        if(sum < 0){
                            //左边指针向右移
                            if(left < right - 1){
                                while (nums[left] == nums[++left]){
                                    //跳过重复值
                                    if(left == right){
                                        break;
                                    }
                                }
                            }else{
                                break;
                            }
                        }else{
                            if(right > left + 1){
                                //右边指针向左移
                                while (nums[right] == nums[--right]){
                                    //跳过重复值
                                    if(right == left){
                                        break;
                                    }
                                }
                            }else{
                                break;
                            }

                        }
                    }

                    if(i < length - 2){
                        while (n == nums[++i]){
                            //跳过重复值
                            if(i == length - 2){
                                break;
                            }
                        }
                    }else{
                        break;
                    }

                }
            }
        }

        return list;
    }


    /**
     * 16. 最接近的三数之和
     * @param nums
     * @param target
     * @return
     */
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int length = nums.length;
        int oldAbs = 0;
        int ans = nums[0] + nums[1] + nums[2];
        for (int i = 0; i < length - 2; i++) {
            int n = nums[i];
            int left = i + 1;
            int right = length - 1;
            while (left < right) {
                int sum = n + nums[left] + nums[right];
                int diff = target - sum;
                int abs = Math.abs(diff);

                if (oldAbs == 0 || oldAbs > abs) {
                    oldAbs = abs;
                    ans = sum;
                }

                if (diff < 0) {//比对值小于0时，表示太大了，需要小一点的数来匹配
                    right--;
                } else if(diff > 0) {//比对值大于0时，表示太小了，需要大一点的数来匹配
                    left++;
                }else{
                    return ans;
                }
            }

        }

        return ans;
    }

    /**
     * 17. 电话号码的字母组合
     * @param digits
     * @return
     */
    public List<String> letterCombinations(String digits) {
        List<String> list = new ArrayList<>();
        int length = digits.length();
        if(length == 0){
            return list;
        }

        char[] ch2 = {'a','b','c'};
        char[] ch3 = {'d','e','f'};
        char[] ch4 = {'g','h','i'};
        char[] ch5 = {'j','k','l'};
        char[] ch6 = {'m','n','o'};
        char[] ch7 = {'p','q','r','s'};
        char[] ch8 = {'t','u','v'};
        char[] ch9 = {'w','x','y','z'};

        char[] chs = digits.toCharArray();

        int[] sizes = new int[length];

        for(int i = 0; i < length; i++){
            sizes[i] = numLength(chs[i]);
        }

        int n = length - 1;
        int size = sizes[n];
        int end = n;
        int endSize = size;

        int[] nums = new int[length];

        while (n >= 0){
            leap: while (end >= n){
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < length; i++){
                    switch (chs[i]){
                        case '2':
                            sb.append(ch2[nums[i]]);
                            break;
                        case '3':
                            sb.append(ch3[nums[i]]);
                            break;
                        case '4':
                            sb.append(ch4[nums[i]]);
                            break;
                        case '5':
                            sb.append(ch5[nums[i]]);
                            break;
                        case '6':
                            sb.append(ch6[nums[i]]);
                            break;
                        case '7':
                            sb.append(ch7[nums[i]]);
                            break;
                        case '8':
                            sb.append(ch8[nums[i]]);
                            break;
                        case '9':
                            sb.append(ch9[nums[i]]);
                            break;
                    }

                }

                list.add(sb.toString());

                if(end >= n){
                    if(nums[end] < endSize - 1){
                        nums[end]++;
                    }else if(end > n){
                        while (nums[--end] == sizes[end] - 1){
                            if(end == n){
                                break leap;
                            }
                        }
                        nums[end]++;
                    }else{
                        break;
                    }
                    for(int k = end + 1; k < length; k++){
                        nums[k] = 0;
                    }
                    end = length - 1;
                    endSize = sizes[end];
                }else{
                    break;
                }

            }

            if(n > 0){
                while (nums[--n] == sizes[n] - 1){
                    if(n == 0){
                        return list;
                    }
                }
                nums[n]++;
                for(int k = n + 1; k < length; k++){
                    nums[k] = 0;
                }
                end = length - 1;
                endSize = sizes[end];
            }else{
                break;
            }

        }

        return list;
    }

    private int numLength(char ch){
        if(ch == '7' || ch == '9'){
            return 4;
        }
        return 3;
    }

    /**
     * 18. 四数之和
     * @param nums
     * @param target
     * @return
     */
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> list = new ArrayList<>();
        int length = nums.length;
        if(length >= 4){
            Arrays.sort(nums);

            int n1 = 0;

            while (n1 < length - 3){

                int n4 = length - 1;
                while (n4 > n1 + 2){

                    int n2 =  n1 + 1;
                    int n3 = n4 - 1;
                    while (n2 < n3){
                        int sum = nums[n1] + nums[n2] + nums[n3] + nums[n4];
                        if(sum == target){
                            List<Integer> item = new ArrayList<>();
                            item.add(nums[n1]);
                            item.add(nums[n2]);
                            item.add(nums[n3]);
                            item.add(nums[n4]);
                            list.add(item);
                        }

                        if(sum <= target){
                            if(n2 < n3 - 1){
                                while (nums[n2] == nums[++n2]){
                                    if(n2 == n3){
                                        break;
                                    }
                                }
                            }else{
                                break;
                            }

                        }else if(n3 > n2 + 1){
                            while (nums[n3] == nums[--n3]){
                                if(n3 == n2){
                                    break;
                                }
                            }
                        }else{
                            break;
                        }

                    }

                    if(n4 > n1 + 2){
                        while (nums[n4] == nums[--n4]){
                            if(n4 == n1 + 2){
                                break;
                            }
                        }
                    }else{
                        break;
                    }
                }

                if(n1 < length - 4){
                    while (nums[n1] == nums[++n1]){
                        if(n1 == length - 4){
                            break;
                        }
                    }
                }else{
                    break;
                }
            }
        }

        return list;
    }

    /**
     * 19. 删除链表的倒数第N个节点
     * @param head
     * @param n
     * @return
     */
    public ListNode removeNthFromEnd(ListNode head, int n) {

        int size = listNodeSize(head,0);
        if(size > 1){
            removeNthFromEnd(head,n,size);
            return head;
        }

        return null;
    }

    private int listNodeSize(ListNode listNode,int size){
        if(listNode != null){
            return listNodeSize(listNode.next,++size);
        }
        return size;
    }

    private void removeNthFromEnd(ListNode head, int n , int size) {
        if(head.next != null){
            if(size <= n){
                head.val = head.next.val;
            }
            if(head.next.next != null){
                removeNthFromEnd(head.next,n,--size);
            }else{
                head.next = null;
            }

        }
    }

    /**
     * 20. 有效的括号
     * @param s
     * @return
     */
    public boolean isValid(String s) {
        if(s != null && s.length() > 0){
            Stack<Character> stack = new Stack<>();

            char[] chars = s.toCharArray();
            for(int i = 0; i< chars.length; i++){
                char c = chars[i];
                switch (c){
                    case '(':
                    case '[':
                    case '{':
                        stack.push(c);
                        break;
                    case ')':
                        if(stack.size() > 0 && stack.peek() == '('){
                            stack.pop();
                        }else{
                            return false;
                        }
                        break;
                    case ']':
                        if(stack.size() > 0 && stack.peek() == '['){
                            stack.pop();
                        }else{
                            return false;
                        }
                        break;
                    case '}':
                        if(stack.size() > 0 && stack.peek() == '{'){
                            stack.pop();
                        }else{
                            return false;
                        }
                        break;
                }
            }
            return stack.isEmpty();
        }
        return true;
    }

    /**
     * 21. 合并两个有序链表
     * @param l1
     * @param l2
     * @return
     */
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        List<Integer> list = new ArrayList<>();

        if(l1 != null){
            getListByListNode(list,l1);
        }

        if(l2 != null){
            getListByListNode(list,l2);
        }

        int size = list.size();
        for(int i = 0; i< size - 1; i++){
            for(int j = 0; j < size - i - 1; j++){
                int val1 = list.get(j);
                int val2 = list.get(j + 1);
                if(val1 > val2){
                    int temp = val1;
                    list.set(j,val2);
                    list.set(j + 1,temp);
                }

            }
        }
        ListNode listNode = null;
        if(!list.isEmpty()){
            listNode = new ListNode(list.get(0));
            getListNodeByList(list,listNode,1);
        }

        return listNode;
    }

    private void getListByListNode(List<Integer> list,ListNode listNode){
        if(listNode != null){
            list.add(listNode.val);
            getListByListNode(list,listNode.next);
        }
    }

    private void getListNodeByList(List<Integer> list,ListNode listNode,int pos){
        if(pos < list.size()){
            listNode.next = new ListNode(list.get(pos));
            pos++;
            getListNodeByList(list,listNode.next,pos);
        }

    }

    /**
     * 22. 括号生成
     * @param n
     * @return
     */
    public List<String> generateParenthesis(int n) {
        char[] ch = {'(',')'};
        List<String> list = new ArrayList<>();

        return list;
    }

    /**
     * 23. 合并K个排序链表
     * @param lists
     * @return
     */
    public ListNode mergeKLists(ListNode[] lists) {
        List<Integer> list = new ArrayList<>();
        int length = lists.length;
        for(int i = 0; i < length; i++){
            listNodeToList(list,lists[i]);
        }
        Collections.sort(list);

        int size = list.size();
        if(size > 0){
            ListNode listNode = new ListNode(list.get(0));
            listToListNode(listNode,list,1,size);
            return listNode;
        }

        return null;
    }

    private void listNodeToList(List<Integer> list,ListNode listNode){
        if(listNode != null){
            list.add(listNode.val);
            listNodeToList(list,listNode.next);
        }
    }

    private void listToListNode(ListNode listNode,List<Integer> list,int pos,int size){
        if(pos < size){
            listNode.next = new ListNode(list.get(pos));
            listToListNode(listNode.next,list,++pos,size);
        }
    }

    /**
     * 24. 两两交换链表中的节点
     * @param head
     * @return
     */
    public ListNode swapPairs(ListNode head) {
        if(head != null && head.next != null){
            ListNode listNode = head.next;
            head.next = swapPairs(listNode.next);
            listNode.next = head;
            return listNode;
        }
        return head;
    }

    private void swap(ListNode head) {
        if(head != null && head.next != null){
            int val = head.val;
            head.val = head.next.val;
            head.next.val = val;
            swap(head.next.next);
        }
    }

    public ListNode reverseKGroup(ListNode head, int k) {
        if(head != null){
            ListNode listNode = reverseKGroup(head,k,1);
            if(listNode != null){
                reverseKGroup(listNode,head,k,k);
            }
            return listNode;
        }
        return head;
    }

    private ListNode reverseKGroup(ListNode head,int k,int p){
        if(head != null && p < k){
            return reverseKGroup(head.next,k, ++p);
        }
        return head;
    }

    private void reverseKGroup(ListNode listNode,ListNode head,int k,int p){
        if(head != null && k > 0){
            if(p == 0){
                if(head.next != null){
                    listNode.next = head.next;
                    if(k > 0){
                        --k;
                        p = k;
                        reverseKGroup(listNode.next,head.next,k,p);
                    }
                }

            }else  if(head.next != null && p > 0){
                reverseKGroup(listNode.next,head.next,k,--p);
            }
        }

    }

    /**
     * 26. 删除排序数组中的重复项
     * @param nums
     * @return
     */
    public int removeDuplicates(int[] nums) {
        int length = nums.length;
        if(length == 0){
            return 0;
        }
        int n = 0;
        for(int i = 1; i < length; i++){
            if(nums[i] != nums[n]){
                n++;
                nums[n] = nums[i];
            }
        }

        return n + 1;

    }

    /**
     * 27. 移除元素
     * @param nums
     * @param val
     * @return
     */
    public int removeElement(int[] nums, int val) {
        int length = nums.length;
        if(length == 0){
            return 0;
        }
        int n = 0;
        for(int i = 0;i< length; i++){
            if(nums[i] != val){
                nums[n] = nums[i];
                n++;
            }
        }
        return n;
    }

    /**
     * 28. 实现strStr
     * @param haystack
     * @param needle
     * @return
     */
    public int strStr(String haystack, String needle) {
        if(needle.isEmpty()){
            return 0;
        }

        int length = needle.length();
        for(int i = 0; i <= haystack.length() - length; i++){
            if(needle.equals(haystack.substring(i, i +  length))){
                return i;
            }
        }

        return -1;
    }

    /**
     * 29. 两数相除
     * @param dividend
     * @param divisor
     * @return
     */
    public int divide(int dividend, int divisor) {

        if(dividend == 0){
            return 0;
        }
        if(dividend == divisor){
            return 1;
        }
        if(divisor == 1){
            return dividend;
        }
        if(divisor == -1){
            if(dividend == Integer.MIN_VALUE){
                return Integer.MAX_VALUE;
            }
            return -dividend;
        }
        if(divisor == Integer.MIN_VALUE){
            return 0;
        }

        boolean isMinus = (dividend > 0 && divisor < 0) || ( dividend < 0 && divisor > 0);

        boolean isMinDividend = (dividend == Integer.MIN_VALUE);
        if(isMinDividend){
            dividend = Integer.MAX_VALUE;
        }else{
            dividend = Math.abs(dividend);
        }

        divisor = Math.abs(divisor);

        if(dividend == divisor){
            return isMinus ? -1 : 1;
        }

        if(dividend > divisor){
            List<Integer> list1 = new ArrayList<>();
            List<Integer> list2 = new ArrayList<>();

            if(isMinDividend){
                dividend = dividend - divisor + 1;
            }else{
                dividend = dividend - divisor;
            }

            int div = 1;
            int sum = divisor;
            list1.add(div);
            list2.add(sum);
            while (sum < dividend){
                if(sum < dividend - sum){
                    sum += sum;
                    div += div;
                    list1.add(div);
                    list2.add(sum);
                }else if(sum == dividend - sum){
                    return div + div;
                }else{
                    break;
                }
            }

            int size = list1.size();
            div = list1.get(size - 1) + 1;
            sum = list2.get(size - 1);
            dividend -= sum;

            while (dividend > 0){
                for(int i = size - 1; i >= 0; i--){
                    sum = list2.get(i);
                    if(dividend >= sum){
                        dividend -= sum;
                        div += list1.get(i);
                        i++;
                    }
                    if(dividend < divisor){
                        return isMinus ? -div : div;
                    }
                }

                if(dividend < divisor){
                    return isMinus ? -div : div;
                }
            }

            return isMinus ? -1 : 1;
        }

        return 0;
    }


    /**
     * 31. 下一个排列
     * @param nums
     */
    public void nextPermutation(int[] nums) {
        int length = nums.length;
        if(length > 1){
            int max = nums[length - 1];
            for(int i = length - 2; i >= 0; i--){
                if(nums[i] < nums[i + 1]){
                    int temp = nums[i];
                    int p =  i + 1;
                    if(temp >= max){
                        nums[i] = nums[i + 1];
                        nums[i + 1] = temp;
                    }else{
                        if(p < length - 1){
                            for(int j = length - 1; j >= p; j--){
                                if(nums[j] > temp){
                                    nums[i] = nums[j];
                                    nums[j] = temp;
                                    break;
                                }
                            }
                        }else{
                            nums[i] = nums[i + 1];
                            nums[i + 1] = temp;
                            return;
                        }
                    }

                    int num = nums[p];
                    for(int j = p, k = length - 1;j < k; j++,k--){
                        int numMin = nums[k];
                        int numMax = nums[j + 1];
                        if(num < numMin){
                            nums[j] = num;
                            num = numMin;
                        }else{
                            nums[j] = numMin;
                        }

                        if(num > numMax){
                            nums[k] = num;
                            num = numMax;
                        }else{
                            nums[k] = numMax;
                        }

                    }
                    return;
                }else{
                    max = Math.max(max, nums[i + 1]);
                }

            }

            for(int i = 0; i < length - 1; i++){
                for(int j = 0; j < length - 1 - i; j++){
                    if(nums[j] > nums[j + 1]){
                        int temp = nums[j];
                        nums[j] = nums[j + 1];
                        nums[j + 1] = temp;
                    }
                }
            }
        }

    }

    /**
     * 33. 搜索旋转排序数组
     * @param nums
     * @param target
     * @return
     */
    public int search(int[] nums, int target) {
        int length = nums.length;
        for(int i = 0; i < length; i++){
            if(target == nums[i]){
                return i;
            }
        }
        return -1;
    }

    /**
     * 35. 搜索插入位置
     * @param nums
     * @param target
     * @return
     */
    public int searchInsert(int[] nums, int target) {

        int length = nums.length;
        if(length == 0){
            return 0;
        }

        for(int i = 0; i < length; i++){
            if(target <= nums[i]){
                return i;
            }
        }

        return length;
    }

    /**
     * 36. 有效的数独
     * @param board
     * @return
     */
    public boolean isValidSudoku(char[][] board) {
        char chDot = '.';
        for(int i = 0; i < 9; i++){
            Set<Character> setRow = new HashSet<>();
            Set<Character> setCol = new HashSet<>();
            for(int j = 0; j < 9; j++){
                 if(board[i][j] != chDot){
                     if(setRow.contains(board[i][j])){
                         return false;
                     }
                     setRow.add(board[i][j]);
                 }
                 if(board[j][i] != chDot){
                     if(setCol.contains(board[j][i])){
                         return false;
                     }
                     setCol.add(board[j][i]);
                 }
            }
        }
        int rowSize = 3;
        while (rowSize <= 9 ){
            int colSize = 3;
            while (colSize <= 9){
                Set<Character> setGrid = new HashSet<>();
                int i = rowSize - 3;
                while (i < rowSize){
                    int j = colSize - 3;
                    while (j < colSize){
                        if(board[i][j] != chDot){
                            if(setGrid.contains(board[i][j])){
                                return false;
                            }
                            setGrid.add(board[i][j]);
                        }
                        j++;
                    }
                    i++;
                }
                colSize += 3;
            }
            rowSize += 3;
        }

        return true;
    }

    /**
     * 38. 外观数列
     * 1.     1
     * 2.     11
     * 3.     21
     * 4.     1211
     * 5.     111221
     * 6.     312211
     * 7.     13112221
     * 8.     1113213211
     * 9.     31131211131221
     * 10.    13211311123113112211
     * @param n
     */
    public String countAndSay(int n) {
        String str = "1";
        for(int i = 2; i <= n; i++){
            str = nextAndSay(str);
        }
        return str;
    }

    private String nextAndSay(String str) {
        int n = 0;
        StringBuilder sb = new StringBuilder();
        char ch = str.charAt(0);
        for(int i = 0; i< str.length(); i++){
            char c = str.charAt(i);
            if(ch == c){
                n++;
            }else{
                sb.append(n).append(ch);
                ch = c;
                n = 1;
            }
        }
        sb.append(n).append(ch);

        return sb.toString();
    }


    /**
     * 53. 最大子序和
     * @param nums
     * @return
     */
    public int maxSubArray(int[] nums) {
        int max = nums[0];
        int length = nums.length;
        for(int i = 1; i < length; i++){
            if(nums[i - 1] > 0){
                nums[i] += nums[i -1];
            }
            if(nums[i] > max){
                max = nums[i];
            }
        }
        return max;
    }

    /**
     * 58. 最后一个单词的长度
     * @param s
     * @return
     */
    public int lengthOfLastWord(String s) {
        String[] ss = s.split(" ");
        int length = ss.length;
        if(length > 0){
            return ss[length - 1].length();
        }

        return 0;
    }

    /**
     * 66. 加一
     * @param digits
     * @return
     */
    public int[] plusOne(int[] digits) {
        int length = digits.length;
        if(digits[length - 1] == 9){

            for(int i = length -1; i >= 0; i--){
                if(digits[i] != 9){
                    digits[i] += 1;
                    return digits;
                }else{
                    digits[i] = 0;
                }
            }
            int[] res = new int[length + 1];
            res[0] = 1;
            return res;
        }

        digits[length -1] += 1;
        return digits;
    }

    /**
     * 67. 二进制求和
     * @param a
     * @param b
     * @return
     */
    public String addBinary(String a, String b) {

        int length1 = a.length();
        int length2 = b.length();
        char[] as = a.toCharArray();
        char[] bs = b.toCharArray();

        if(length1 > length2){
            return addBinary(as,bs,length1,length2);
        }
        return addBinary(bs,as,length2,length1);
    }

    private String addBinary(char[] ch1, char[] ch2,int length,int minLength){

        StringBuilder sb = new StringBuilder();
        int n = 0;
        int size = length - minLength;
        for(int i = length -1; i >= 0; i--){
            if(ch1[i] == '1'){
                n++;
            }
            if(i >= size){
                if(ch2[i - size] == '1'){
                    n++;
                }
            }
            sb.insert(0,n % 2);
            n /= 2;
        }

        addBinary(sb,n);

        return sb.toString();
    }

    private void addBinary(StringBuilder builder,int n){
        if(n > 0){
            builder.insert(0,n % 2);
            addBinary(builder, n / 2);
        }
    }


    /**
     * 70. 爬楼梯
     * @param n
     *      2.  2
     *      3.  3
     *      4.  5
     *      5.  8
     *      6.  13
     * @return
     */
    public int climbStairs(int n) {
        if(n > 3){
            return climbStairs(3,2,3,n);
        }
        return n;
    }

    private int climbStairs(int i,int a,int b,int n) {
        if(i < n){
            return climbStairs(++i, b, a + b, n);
        }
        return b;
    }

    /**
     * 151. 翻转字符串里的单词
     * @param s
     * @return
     */
    public String reverseWords(String s) {
        s = s.trim();
        if(s.length() > 0){
            String[] strs = s.split(" ");
            StringBuilder sb = new StringBuilder();
            int length = strs.length;
            for(int i =  length - 1; i >= 0; i--){
                String si = strs[i].trim();
                if(si.length() > 0){
                    sb.append(si);
                    if(i > 0){
                        sb.append(" ");
                    }
                }

            }
            return sb.toString();
        }

        return s;
    }

    /**
     * 83. 删除排序链表中的重复元素
     * @param head
     * @return
     */
    public ListNode deleteDuplicates(ListNode head) {
        if(head != null){
            deleteDuplicates(head,head.val);
        }
        return head;
    }

    private void deleteDuplicates(ListNode listNode,int n){
        if(listNode.next != null){
            if(listNode.next.val == n){
                listNode.next = listNode.next.next;
                if(listNode.next != null){
                    deleteDuplicates(listNode,n);
                }
            }else{
                deleteDuplicates(listNode.next,listNode.next.val);
            }
        }
    }

    /**
     * 88. 合并两个有序数组
     * @param nums1
     * @param m
     * @param nums2
     * @param n
     */
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        for(int i = m,j = 0; i < m + n; i++,j++){
            nums1[i] = nums2[j];
        }
        Arrays.sort(nums1);
    }

    /**
     * 121. 买卖股票的最佳时机
     * @param prices
     * @return
     */
    public int maxProfit(int[] prices) {
        int length = prices.length;
        int max = 0;
        if(length > 1){
            int size = length - 1;
            int[] diffs = new int[size];
            for(int i = 0; i < size; i++){
                diffs[i] = prices[i+1] - prices[i];
            }

            int last = 0;
            for(int i = 0; i < size; i++){
                last = Math.max(0,last + diffs[i]);
                max = Math.max(max,last);
            }
        }

        return max;
    }

    /**
     * 169. 多数元素
     * @param nums
     * @return
     */
    public int majorityElement(int[] nums) {
        int length = nums.length;
        if(length == 1){
            return nums[0];
        }
        int size = (length + 1) / 2;
        Map<Integer,Integer> map = new HashMap<>();
        for(int i = 0; i < length; i++){
            int num = nums[i];
            if(!map.containsKey(num)){
                map.put(num,1);
            }else{
                int val = map.get(num);
                if(++val >= size){
                    return num;
                }
                map.put(num,val);
            }
        }

        return 0;
    }


    /**
     * 206. 反转链表
     * @param head
     * @return
     */
    public ListNode reverseList(ListNode head) {
        if(head != null){
            return reverse(null,head);
        }
        return head;
    }

    private ListNode reverse(ListNode list,ListNode head) {
        if(head != null){
            ListNode listNode = new ListNode(head.val);
            listNode.next = list;
            return reverse(listNode,head.next);
        }

        return list;
    }

    /**
     * 300. 最长上升子序列
     * @param nums
     * @return
     */
    public int lengthOfLIS(int[] nums) {
        int length = nums.length;
        if(length < 2){
            return length;
        }
        int ans = 0;
        int max = nums[length - 1];
        int[] dp = new int[length];
        dp[length - 1] = 1;
        for(int i = length - 2; i >= 0; i--){
            int num = nums[i];
            if(num < max){
                for(int j = i + 1; j < length; j++){
                    if(num < nums[j]){
                        dp[i] = Math.max(dp[i],dp[j] + 1);
                    }
                }
            }else{
                dp[i] = 1;
            }
            max = Math.max(max,num);
            ans = Math.max(ans,dp[i]);
        }

        return ans;
    }


    /**
     * 322. 零钱兑换
     * @param coins
     * @param amount
     * @return
     */
    public int coinChange(int[] coins, int amount) {
        if(amount == 0){
            return 0;
        }
        int length = coins.length;

        Arrays.sort(coins);

        int ans = coinChange(coins,amount,length,length - 1,0,amount + 1);

        return ans > amount ? -1 : ans;
    }


    private int coinChange(int[] coins, int amount,int length,int  pos, int count,int ans) {
        if(amount == 0){
            return Math.min(ans,count);
        }

        if(pos >= 0){
            for(int i = amount / coins[pos]; i >=0 && i + count < ans; i--){
                ans = Math.min(ans,coinChange(coins,amount - i * coins[pos],length,pos - 1,count + i, ans));
            }
        }

        return ans;
    }


    /**
     * 365. 水壶问题
     * @param x
     * @param y
     * @param z
     * @return
     */
    public boolean canMeasureWater(int x, int y, int z) {
        if(z == 0){
            return true;
        }
        if(x == 0 || y == 0){
            return x + y == z;
        }
        if(x + y < z){
            return false;
        }
        return z % gcd(x,y) == 0;
    }


    /**
     * 409. 最长回文串 - 与第5类似
     * @param s
     * @return
     */
    public int longestPalindrome1(String s) {
        int length = s.length();
        if(length < 2){
            return length;
        }

        int ans = 0;
        Map<Character,Integer> map = new HashMap<>();
        for(int i = 0; i < length; i++){
            char ch = s.charAt(i);
            if(map.containsKey(ch)){
                ans += 2;
                map.remove(ch);
            }else{
                map.put(ch,1);
            }
        }

        if(!map.isEmpty()){
            ans++;
        }

        return ans;
    }


    /**
     * 543. 二叉树的直径
     * @param root
     * @return
     */
    public int diameterOfBinaryTree(TreeNode root) {
        depth(root);
        return max;
    }

    int max = 0;
    private int depth(TreeNode treeNode){
        if(treeNode == null){
            return 0;
        }
        int leftDepth = depth(treeNode.left);
        int rightDepth = depth(treeNode.right);
        int depth = leftDepth + rightDepth;
        if(max < depth){
            max = depth;
        }
        return Math.max(leftDepth,rightDepth) + 1;
    }


    /**
     * 695. 岛屿的最大面积
     * @param grid
     * @return
     */
    public int maxAreaOfIsland(int[][] grid) {
        int length = grid.length;
        int max = 0;
        for(int i = 0; i < length; i++){
            for(int j = 0; j < grid[i].length; j++){
                if(grid[i][j] != 0){
                    max = Math.max(max,maxAreaOfIsland(grid,i,j,length));
                }
            }
        }
        return max;
    }

    private int maxAreaOfIsland(int[][] grid,int i,int j,int length){
        if(i < 0 || i >= length){
            return 0;
        }
        if(j < 0 || j >= grid[i].length){
            return 0;
        }
        if(grid[i][j] != 0){
            grid[i][j] = 0;
            return 1 + maxAreaOfIsland(grid,i - 1,j,length) + maxAreaOfIsland(grid,i + 1,j,length)
                    + maxAreaOfIsland(grid,i,j - 1,length) + maxAreaOfIsland(grid,i,j + 1,length);
        }
        return 0;
    }

    /**
     * 820. 单词的压缩编码
     * @param words
     * @return
     */
    public int minimumLengthEncoding(String[] words) {
        int length = words.length;
        for(int i = 0; i < length - 1; i++){
            for(int j = 0; j < length - 1 - i; j++){
                if(words[j].length() < words[j + 1].length()){
                    String temp = words[j];
                    words[j] = words[j + 1];
                    words[j + 1] = temp;
                }
            }
        }
        int[] dp = new int[length];
        for(int i = 0; i < length - 1; i++){
            String word = words[i];
            if(dp[i] == 0){
                for(int j = i + 1; j < length; j++){
                    if(dp[j] == 0 && word.endsWith(words[j])){
                        dp[j] = -1;
                    }
                }
            }

        }
        int ans = 0;
        for(int i = 0; i < length; i++){
            if(dp[i] == 0){
                ans += words[i].length() + 1;
            }
        }

        return ans;
    }

    public int minimumLengthEncoding2(String[] words) {
        int length = words.length;

        int[] dp = new int[length];
        for(int i = 0; i < length; i++){
            String word = words[i];
            if(dp[i] >= 0){
                int len = word.length();
                for(int j = 0; j < length; j++){
                    if(i != j && dp[j] >= 0){
                        if(len > words[j].length()){
                            if(word.endsWith(words[j])){
                                dp[j] = -1;
                            }
                        }else if(words[j].endsWith(word)){
                            dp[i] = -1;
                            break;
                        }
                    }
                }
            }
        }
        int ans = 0;
        for(int i = 0; i < length; i++){
            if(dp[i] == 0){
                ans += words[i].length() + 1;
            }
        }

        return ans;
    }

    /**
     * 836. 矩形重叠
     * @param rec1
     * @param rec2
     * @return
     */
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        if(rec1[0] >= rec2[2] || rec1[2] <= rec2[0] || rec1[1] >= rec2[3] || rec1[3] <= rec2[1]){
            return false;
        }
        return true;
    }

    /**
     * 876. 链表的中间结点
     * @param head
     * @return
     */
    public ListNode middleNode(ListNode head) {
        List<ListNode> list = new ArrayList<>();
        middleNode(list,head);
        int index =  list.size() / 2;
        return list.get(index);
    }

    private void middleNode(List<ListNode> list,ListNode head){
        if(head != null){
            list.add(head);
            middleNode(list,head.next);
        }
    }

    /**
     * 892. 三维形体的表面积
     * @param grid
     * @return
     */
    public int surfaceArea(int[][] grid) {
        int n = grid.length;
        int a = 0;
        int b = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] != 0){
                    a += grid[i][j];
                    b += (grid[i][j] - 1) * 2;

                    if(j > 0){
                        b += Math.min(grid[i][j - 1],grid[i][j]) * 2;
                    }

                    if(i > 0){
                        b += Math.min(grid[i - 1][j],grid[i][j]) * 2;
                    }
                }
            }
        }

        return a * 6 - b;
    }

    /**
     * 912. 排序数组
     * @param nums
     * @return
     */
    public int[] sortArray(int[] nums) {
        Arrays.sort(nums);
        return nums;
    }

    public int[] sortArray1(int[] nums) {
        int length = nums.length;
        Queue<Integer> queue = new PriorityQueue<>();
        for(int i = 0; i < length; i++){
            queue.add(nums[i]);
        }
        for(int i = 0; i < length; i++){
            nums[i] = queue.poll();
        }
        return nums;
    }

    /**
     * 914. 卡牌分组
     * @param deck
     * @return
     */
    public boolean hasGroupsSizeX(int[] deck) {
        int length = deck.length;
        if(length > 1){
            if(length == 2){
                return deck[0] == deck[1];
            }
            Arrays.sort(deck);
            int n = 0;
            int count = 1;
            int num = deck[0];
            for(int i = 1;  i < length; i++){
                if(deck[i] == num){
                    count++;
                }else{
                    if(count < 2){
                        return false;
                    }
                    if(n == 0){
                        n = count;
                    }else{
                        int gcd = gcd(n,count);
                        if(gcd < 2){
                            return false;
                        }
                        n = gcd;
                    }
                    count = 1;
                    num = deck[i];
                }
            }
            if(count < 2){
                return false;
            }
            n = gcd(n,count);
            return n >= 2;
        }
        return false;
    }

    /**
     * 945. 使数组唯一的最小增量
     * @param A
     * @return
     */
    public int minIncrementForUnique(int[] A) {
        int length =  A.length;
        if(length < 2){
            return 0;
        }
        Arrays.sort(A);

        Set<Integer> set = new HashSet<>();
        set.add(A[0]);
        List<Integer> list = new ArrayList<>();
        for(int i = 1; i < length; i++){
            if(A[i] == A[i - 1]){
                list.add(i);
            }else{
                set.add(A[i]);
            }
        }

        int ans = 0;
        int size = list.size();
        if(size > 0){
            int j = 0;
            int i = list.get(j);
            int p = i + 1;
            int num = A[i] + 1;
            int last = A[length - 1];
            while (j < size){
                if(num < last){
                    leap : for(int k = p; k < length; k++){
                        while (num < A[k]){
                            if(!set.contains(num)){
                                ans += num - A[i];
                                A[i] = num;
                                set.add(num);
                                p = k;
                                break leap;
                            }
                            num++;
                        }
                        p = k;
                        if(k == length - 1){
                            while (set.contains(num)){
                                num++;
                            }
                            ans += num - A[i];
                            A[i] = num;
                            set.add(num);
                        }
                    }

                }else{
                    while (set.contains(num)){
                        num++;
                    }
                    ans += num - A[i];
                    A[i] = num;
                    set.add(num);
                }

                if(++j < size){
                    i = list.get(j);
                    num = Math.max(num + 1,A[i] + 1);
                }
            }
        }

        return ans;
    }

    /**
     * 994. 腐烂的橘子
     * @param grid
     * @return
     */
    public int orangesRotting(int[][] grid) {
        return orangesRotting(0,grid);
    }

    private int orangesRotting(int n,int[][] grid) {

        boolean isOne = false;
        boolean bool = false;

        int row = grid.length;
        int col = grid[0].length;
        int[][] nums = new int[row][col];
        int i = 0;
        while (i < row){
            int j = 0;
            while (j < col){
                int num = grid[i][j];
                if(num == 1){
                    isOne = true;
                    if(i > 0){
                        int top = grid[i - 1][j];
                        if(top == 2){
                            nums[i][j] = 2;
                            bool = true;
                            j++;
                            continue;
                        }
                    }

                    if(i < row - 1){
                        int bottom = grid[i + 1][j];
                        if(bottom == 2){
                            nums[i][j] = 2;
                            bool = true;
                            j++;
                            continue;
                        }
                    }

                    if(j > 0){
                        int left = grid[i][j - 1];
                        if(left == 2){
                            nums[i][j] = 2;
                            bool = true;
                            j++;
                            continue;
                        }
                    }

                    if(j < col - 1){
                        int right = grid[i][j + 1];
                        if(right == 2){
                            nums[i][j] = 2;
                            bool = true;
                            j++;
                            continue;
                        }
                    }

                }

                nums[i][j] = num;
                j++;

            }

            i++;
        }

        if(bool){
            return orangesRotting(++n, nums);
        }else if(isOne){
            n = -1;
        }

        return n;
    }


    /**
     * 999. 车的可用捕获量
     * @param board
     * @return
     */
    public int numRookCaptures(char[][] board) {
        char rook = 'R';
        char bishop = 'B';
        char pawn = 'p';
        int ans = 0;
        int m = 0;
        int n = 0;
        leap: for(int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                if (board[i][j] == rook) {
                    m = i;
                    n = j;
                    break leap;
                }
            }
        }

        for(int k = m - 1; k >= 0; k--){
            if(board[k][n] == bishop){
                break;
            }else if(board[k][n] == pawn){
                ans += 1;
                break;
            }
        }
        for(int k = m + 1; k < 8; k++){
            if(board[k][n] == bishop){
                break;
            }else if(board[k][n] == pawn){
                ans += 1;
                break;
            }
        }
        for(int k = n - 1; k >= 0; k--){
            if(board[m][k] == bishop){
                break;
            }else if(board[m][k] == pawn){
                ans += 1;
                break;
            }
        }
        for(int k = n + 1; k < 8; k++){
            if(board[m][k] == bishop){
                break;
            }else if(board[m][k] == pawn){
                ans += 1;
                break;
            }
        }
        return ans;


    }

    /**
     * 1013. 将数组分成和相等的三个部分
     * @param A
     * @return
     */
    public boolean canThreePartsEqualSum(int[] A) {
        int length = A.length;
        int[] sums = new int[length];
        sums[0] = A[0];
        for(int i = 1; i < length; i++){
            sums[i] = sums[i - 1] + A[i];
        }

        int sum = sums[length - 1];
        if(sum % 3 == 0){
            int num = sum / 3;
            int num2 = num * 2;
            boolean isBool = false;
            for(int i = 0; i < length - 1; i++){
                if(sums[i] == num){
                    if(isBool){
                        return true;
                    }else{
                        num *= 2;
                        isBool = true;
                    }
                }
            }
        }

        return false;
    }

    /**
     * 1071. 字符串的最大公因子
     * @param str1
     * @param str2
     * @return
     */
    public String gcdOfStrings(String str1, String str2) {
        if((str1 + str2).equals(str2 + str1)){
            int length1 = str1.length();
            int length2 = str2.length();
            return str1.substring(0,gcd(length1,length2));
        }

        return "";
    }

    private int gcd(int a,int b){
        if(a % b == 0){
            return  b;
        }
        return gcd(b,a % b);
    }

    /**
     * 1103. 分糖果 II
     * @param candies
     * @param num_people
     * @return
     */
    public int[] distributeCandies(int candies, int num_people) {
        int n = 1;
        int[] nums = new int[num_people];
        while (candies > 0){
            for(int i = 0; i < num_people; i++){
                if(candies >= n){
                    nums[i] += n;
                    candies -= n;
                    n++;
                }else{
                    nums[i] += candies;
                    candies = 0;
                    break;
                }
            }
        }

        return nums;
    }

    /**
     * 1160. 拼写单词
     * @param words
     * @param chars
     * @return
     */
    public int countCharacters(String[] words, String chars) {
        Map<Character,Integer> mapChars = new HashMap<>();
        int length = chars.length();
        if(length > 0){
            for(int i = 0; i < length; i++){
                char ch = chars.charAt(i);
                if(mapChars.containsKey(ch)){
                    mapChars.put(ch,mapChars.get(ch) + 1);
                }else{
                    mapChars.put(ch,1);
                }
            }
            int ans = 0;
            for(String str : words){
                int size = str.length();
                if(size > 0 && size <= length){
                    Map<Character,Integer> map = new HashMap<>();
                    map.putAll(mapChars);
                    for(int i = 0; i < size; i++){
                        if(map.containsKey(str.charAt(i))){
                            int n = map.get(str.charAt(i));
                            if(n > 1){
                                n--;
                                map.put(str.charAt(i),n);
                            }else{
                                map.remove(str.charAt(i));
                            }
                        }else{
                            size = 0;
                            break;
                        }
                    }
                    ans += size;
                }

            }
            return ans;
        }

        return  0;
    }

    /**
     * 1162. 地图分析
     * @param grid
     * @return
     */
    public int maxDistance(int[][] grid) {
        Queue<int[]> queue = new ArrayDeque<>();
        int length = grid.length;

        for(int i = 0; i < length; i++){
            for(int j = 0; j < length; j++){
                if(grid[i][j] == 1){
                    queue.add(new int[]{i,j});
                }
            }
        }

        int[] dx = {0,0,-1,1};
        int[] dy = {-1,1,0,0};

        boolean isOcean = false;
        int x = 0;
        int y = 0;
        while (!queue.isEmpty()){
            int[] pos = queue.poll();
            x = pos[0];
            y = pos[1];
            for(int i = 0; i < 4; i++){
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(isIndex(nx,ny,length) && grid[nx][ny] == 0){
                    isOcean = true;
                    grid[nx][ny] = grid[x][y] + 1;
                    queue.add(new int[]{nx,ny});
                }
            }
        }

        if(isOcean){
            return grid[x][y] - 1;
        }

        return -1;
    }

    private boolean isIndex(int i,int j,int length){
        if(i < 0 || i >= length){
            return false;
        }
        if(j < 0 || j >= length){
            return false;
        }

        return true;
    }

    /**
     * 1365. 有多少小于当前数字的数字
     * @param nums
     * @return
     */
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int length = nums.length;
        int[] sizes = new int[length];

        for(int i = 0; i < length; i++){
            int num = nums[i];
            int n = 0;
            for(int j = 0; j < length; j++){
                if(nums[j] < num){
                    n++;
                }
            }
            sizes[i] = n;
        }

        return sizes;
    }

    public static void main(String[] args) {
        LeetCode leetCode = new LeetCode();


    }
}
